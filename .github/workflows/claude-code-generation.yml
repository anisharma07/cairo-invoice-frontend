name: Claude AI Code Generation

on:
  issues:
    types: [opened, edited]
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      task_description:
        description: "Describe the code generation task"
        required: true
        type: string
      target_branch:
        description: "Target branch for the generated code"
        required: false
        default: "claude-generated"
        type: string

jobs:
  debug-workflow:
    runs-on: ubuntu-latest
    steps:
      - name: Debug workflow trigger
        run: |
          echo "=== WORKFLOW DEBUG INFO ==="
          echo "Event name: ${{ github.event_name }}"
          echo "Repository: ${{ github.repository }}"
          echo "Actor: ${{ github.actor }}"
          echo "Ref: ${{ github.ref }}"

          if [ "${{ github.event_name }}" = "issues" ]; then
            echo "Issue number: ${{ github.event.issue.number }}"
            echo "Issue title: ${{ github.event.issue.title }}"
            echo "Issue labels: ${{ toJSON(github.event.issue.labels) }}"
            echo "Issue body: ${{ github.event.issue.body }}"
          elif [ "${{ github.event_name }}" = "issue_comment" ]; then
            echo "Comment ID: ${{ github.event.comment.id }}"
            echo "Comment body: ${{ github.event.comment.body }}"
            echo "Issue number: ${{ github.event.issue.number }}"
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "Manual trigger"
            echo "Task description: ${{ github.event.inputs.task_description }}"
            echo "Target branch: ${{ github.event.inputs.target_branch }}"
          fi

  generate-code:
    runs-on: ubuntu-latest
    needs: debug-workflow
    # Always run - removed restrictive conditions to prevent skipping
    if: always() && !cancelled()

    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
        continue-on-error: false
        timeout-minutes: 5

      - name: Validate environment and determine if should proceed
        id: validate
        run: |
          echo "=== VALIDATION CHECK ==="
          SHOULD_PROCEED=false

          # Check if triggered by valid events
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "‚úÖ Triggered by manual dispatch"
            SHOULD_PROCEED=true
          elif [ "${{ github.event_name }}" = "issues" ]; then
            if [[ "${{ toJSON(github.event.issue.labels.*.name) }}" == *"claude-generate"* ]]; then
              echo "‚úÖ Issue has claude-generate label"
              SHOULD_PROCEED=true
            else
              echo "‚ÑπÔ∏è Issue doesn't have claude-generate label, but proceeding anyway"
              SHOULD_PROCEED=true
            fi
          elif [ "${{ github.event_name }}" = "issue_comment" ]; then
            COMMENT="${{ github.event.comment.body }}"
            if [[ "$COMMENT" == *"/claude generate"* ]] || [[ "$COMMENT" == *"/claude-generate"* ]] || [[ "$COMMENT" == *"claude generate"* ]] || [[ "$COMMENT" == *"@claude generate"* ]]; then
              echo "‚úÖ Comment contains trigger phrase"
              SHOULD_PROCEED=true
            else
              echo "‚ÑπÔ∏è Comment doesn't contain trigger phrase, but proceeding anyway"
              SHOULD_PROCEED=true
            fi
          fi

          echo "should_proceed=$SHOULD_PROCEED" >> $GITHUB_OUTPUT

      - name: Debug condition evaluation
        run: |
          echo "=== CONDITION DEBUG ==="
          echo "Event name: ${{ github.event_name }}"
          if [ "${{ github.event_name }}" = "issues" ]; then
            echo "Checking issue labels for 'claude-generate'..."
            echo "Labels: ${{ toJSON(github.event.issue.labels.*.name) }}"
            echo "Contains claude-generate: ${{ contains(github.event.issue.labels.*.name, 'claude-generate') }}"
          elif [ "${{ github.event_name }}" = "issue_comment" ]; then
            echo "Checking comment for trigger phrases..."
            echo "Comment: '${{ github.event.comment.body }}'"
            echo "Contains '/claude generate': ${{ contains(github.event.comment.body, '/claude generate') }}"
            echo "Contains '/claude-generate': ${{ contains(github.event.comment.body, '/claude-generate') }}"
            echo "Contains 'claude generate': ${{ contains(github.event.comment.body, 'claude generate') }}"
            echo "Contains '@claude generate': ${{ contains(github.event.comment.body, '@claude generate') }}"
            echo "Overall condition result: ${{ contains(github.event.comment.body, '/claude generate') || contains(github.event.comment.body, '/claude-generate') || contains(github.event.comment.body, 'claude generate') || contains(github.event.comment.body, '@claude generate') }}"
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID || 'dummy' }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY || 'dummy' }}
          aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}
        continue-on-error: true

      - name: Verify secrets and environment
        continue-on-error: true
        run: |
          echo "=== SECRETS CHECK ==="
          echo "AWS_ACCESS_KEY_ID exists: ${{ secrets.AWS_ACCESS_KEY_ID != '' }}"
          echo "AWS_SECRET_ACCESS_KEY exists: ${{ secrets.AWS_SECRET_ACCESS_KEY != '' }}"
          echo "AWS_REGION exists: ${{ secrets.AWS_REGION != '' }}"
          echo "AWS_BEDROCK_MODEL_ID exists: ${{ secrets.AWS_BEDROCK_MODEL_ID != '' }}"
          echo "GITHUB_TOKEN exists: ${{ secrets.GITHUB_TOKEN != '' }}"
          echo "AWS Region: ${{ secrets.AWS_REGION || 'us-east-1' }}"
          echo "Bedrock Model ID: ${{ secrets.AWS_BEDROCK_MODEL_ID || 'anthropic.claude-3-sonnet-20240229-v1:0' }}"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"
        continue-on-error: false
        timeout-minutes: 5

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"
        continue-on-error: false
        timeout-minutes: 5

      - name: Install dependencies
        continue-on-error: true
        timeout-minutes: 10
        run: |
          set +e  # Don't exit on error
          echo "Installing Node.js dependencies..."
          npm install --no-optional --legacy-peer-deps || echo "‚ö†Ô∏è npm install failed, continuing..."

          echo "Installing Python dependencies..."
          pip install boto3 requests --user || echo "‚ö†Ô∏è pip install failed, continuing..."

          echo "‚úÖ Dependency installation completed (with possible warnings)"

      - name: Extract task description
        id: task
        continue-on-error: false
        run: |
          set -e  # Exit on error for this critical step

          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            TASK_DESC="${{ github.event.inputs.task_description }}"
            BRANCH_NAME="${{ github.event.inputs.target_branch }}"
            echo "‚úÖ Using manual dispatch inputs"
          elif [ "${{ github.event_name }}" = "issues" ]; then
            # Extract task from issue body - handle empty body
            ISSUE_BODY="${{ github.event.issue.body }}"
            if [ -z "$ISSUE_BODY" ] || [ "$ISSUE_BODY" = "null" ]; then
              TASK_DESC="Implement feature based on issue title: ${{ github.event.issue.title }}"
            else
              TASK_DESC="$ISSUE_BODY"
            fi
            BRANCH_NAME="claude-generated-issue-${{ github.event.issue.number }}"
            echo "‚úÖ Using issue content"
          else
            # Extract task from comment - handle multiple trigger formats and empty descriptions
            COMMENT_BODY="${{ github.event.comment.body }}"
            echo "Processing comment: $COMMENT_BODY"
            
            # Try different patterns
            TASK_DESC=""
            if echo "$COMMENT_BODY" | grep -q "^/claude generate "; then
              TASK_DESC=$(echo "$COMMENT_BODY" | sed -n 's|^/claude generate \(.*\)|\1|p')
            elif echo "$COMMENT_BODY" | grep -q "^/claude-generate "; then
              TASK_DESC=$(echo "$COMMENT_BODY" | sed -n 's|^/claude-generate \(.*\)|\1|p')
            elif echo "$COMMENT_BODY" | grep -q "@claude generate"; then
              TASK_DESC=$(echo "$COMMENT_BODY" | sed -n 's|.*@claude generate \(.*\)|\1|p')
            elif echo "$COMMENT_BODY" | grep -q "claude generate"; then
              TASK_DESC=$(echo "$COMMENT_BODY" | sed -n 's|.*claude generate \(.*\)|\1|p')
            else
              TASK_DESC="$COMMENT_BODY"
            fi
            
            # Fallback if extraction failed
            if [ -z "$TASK_DESC" ] || [ "$TASK_DESC" = "null" ]; then
              TASK_DESC="Generate code based on comment in issue #${{ github.event.issue.number }}"
            fi
            
            BRANCH_NAME="claude-generated-comment-${{ github.event.comment.id }}"
            echo "‚úÖ Using comment content"
          fi

          # Ensure we have valid values
          if [ -z "$TASK_DESC" ] || [ "$TASK_DESC" = "null" ]; then
            TASK_DESC="Generate code improvement for the project"
          fi

          if [ -z "$BRANCH_NAME" ] || [ "$BRANCH_NAME" = "null" ]; then
            BRANCH_NAME="claude-generated-$(date +%s)"
          fi

          echo "Final task description: $TASK_DESC"
          echo "Final branch name: $BRANCH_NAME"

          # Use multiline output for task description to handle special characters
          echo "description<<EOF" >> $GITHUB_OUTPUT
          echo "$TASK_DESC" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "branch=$BRANCH_NAME" >> $GITHUB_OUTPUT

      - name: Analyze codebase structure
        continue-on-error: true
        timeout-minutes: 5
        run: |
          set +e  # Don't exit on error

          echo "üîç Analyzing codebase structure..."

          # Find source files with error handling
          find . -type f \( -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.jsx" \) \
            -not -path "./node_modules/*" \
            -not -path "./.git/*" \
            -not -path "./dist/*" \
            -not -path "./build/*" > codebase_files.txt 2>/dev/null || echo "Warning: find command had issues"

          echo "Project structure:" > project_context.txt

          # Try tree command, fallback to ls if not available
          if command -v tree >/dev/null 2>&1; then
            tree -I 'node_modules|.git|dist|build' -L 3 >> project_context.txt 2>/dev/null || echo "Tree command failed, using ls" >> project_context.txt
          else
            echo "Tree command not available, using ls -la:" >> project_context.txt
            ls -la >> project_context.txt 2>/dev/null || echo "ls command failed" >> project_context.txt
          fi

          echo -e "\n\nPackage.json content:" >> project_context.txt
          if [ -f "package.json" ]; then
            cat package.json >> project_context.txt 2>/dev/null || echo "Could not read package.json" >> project_context.txt
          else
            echo "package.json not found" >> project_context.txt
          fi

          # Add some basic project info
          echo -e "\n\nBasic project info:" >> project_context.txt
          echo "Working directory: $(pwd)" >> project_context.txt
          echo "Files found: $(wc -l < codebase_files.txt 2>/dev/null || echo 0)" >> project_context.txt
          echo "Date: $(date)" >> project_context.txt

          echo "‚úÖ Codebase analysis completed"

      - name: Generate code with Claude
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          AWS_BEDROCK_MODEL_ID: ${{ secrets.AWS_BEDROCK_MODEL_ID || 'anthropic.claude-3-sonnet-20240229-v1:0' }}
          TASK_DESCRIPTION: ${{ steps.task.outputs.description }}
          TARGET_BRANCH: ${{ steps.task.outputs.branch }}
          AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION || 'us-east-1' }}
        continue-on-error: false
        timeout-minutes: 15
        run: |
          cat << 'EOF' > claude_generator.py
          import boto3
          import json
          import os
          import requests
          import subprocess
          import tempfile
          import time
          import sys
          from typing import Optional, Dict, Any

          def log_info(message: str):
              print(f"‚ÑπÔ∏è {message}")

          def log_success(message: str):
              print(f"‚úÖ {message}")

          def log_warning(message: str):
              print(f"‚ö†Ô∏è {message}")

          def log_error(message: str):
              print(f"‚ùå {message}")

          def retry_operation(func, max_retries=3, delay=2):
              """Retry an operation with exponential backoff"""
              for attempt in range(max_retries):
                  try:
                      return func()
                  except Exception as e:
                      if attempt == max_retries - 1:
                          raise e
                      log_warning(f"Attempt {attempt + 1} failed: {str(e)}. Retrying in {delay} seconds...")
                      time.sleep(delay)
                      delay *= 2

          def get_bedrock_client():
              try:
                  region = os.environ.get('AWS_DEFAULT_REGION', 'us-east-1')
                  return boto3.client('bedrock-runtime', region_name=region)
              except Exception as e:
                  log_error(f"Failed to create Bedrock client: {str(e)}")
                  return None

          def read_file_safely(filepath: str, max_lines: int = 100) -> str:
              """Read file content safely, limiting lines for context"""
              try:
                  with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                      lines = f.readlines()
                      if len(lines) > max_lines:
                          return ''.join(lines[:max_lines]) + f'\n... (truncated, {len(lines)-max_lines} more lines)'
                      return ''.join(lines)
              except Exception as e:
                  return f"Error reading file {filepath}: {str(e)}"

          def analyze_codebase() -> str:
              """Analyze the current codebase structure"""
              context = "=== CODEBASE ANALYSIS ===\n\n"
              
              try:
                  # Read project context
                  if os.path.exists('project_context.txt'):
                      context += "=== PROJECT CONTEXT ===\n"
                      context += read_file_safely('project_context.txt', 200)
                      context += "\n\n"
                  
                  # Read key configuration files
                  key_files = ['package.json', 'tsconfig.json', 'vite.config.ts', 'capacitor.config.ts']
                  for file in key_files:
                      if os.path.exists(file):
                          context += f"=== {file} ===\n"
                          context += read_file_safely(file, 50)
                          context += "\n\n"
                  
                  # Sample some source files to understand patterns
                  if os.path.exists('codebase_files.txt'):
                      try:
                          with open('codebase_files.txt', 'r') as f:
                              files = [line.strip() for line in f.readlines()[:10]]  # First 10 files
                          
                          for file in files:
                              if os.path.exists(file):
                                  context += f"=== {file} ===\n"
                                  context += read_file_safely(file, 30)
                                  context += "\n\n"
                      except Exception as e:
                          context += f"Error reading codebase files: {str(e)}\n"
                  
                  log_success("Codebase analysis completed")
                  return context
              
              except Exception as e:
                  log_error(f"Codebase analysis failed: {str(e)}")
                  return "Codebase analysis failed, proceeding with minimal context."

          def generate_code_with_claude(task_description: str, codebase_context: str) -> str:
              """Generate code using Claude with fallback options"""
              
              def _make_claude_request():
                  client = get_bedrock_client()
                  if not client:
                      raise Exception("Cannot create Bedrock client")
                  
                  prompt = f"""
          You are an expert software developer working on an Ionic React TypeScript application for government billing/invoicing.

          TASK: {task_description}

          CURRENT CODEBASE CONTEXT:
          {codebase_context[:15000]}  # Limit context size

          Please generate the necessary code changes to implement the requested feature. Your response should include:

          1. **FILES_TO_CREATE**: List any new files that need to be created with their full paths
          2. **FILES_TO_MODIFY**: List any existing files that need to be modified
          3. **CODE_CHANGES**: Provide the actual code for new files or specific changes for existing files
          4. **INSTRUCTIONS**: Any additional setup or configuration steps needed

          Follow these guidelines:
          - Use TypeScript and React hooks
          - Follow Ionic React patterns and components
          - Maintain consistency with existing code style
          - Include proper error handling
          - Add appropriate TypeScript types
          - Use existing utilities and patterns from the codebase
          - Ensure mobile-first responsive design

          Format your response clearly with sections for each file change.
          """

                  body = {
                      "anthropic_version": "bedrock-2023-05-31",
                      "max_tokens": 8000,
                      "messages": [
                          {
                              "role": "user",
                              "content": prompt
                          }
                      ]
                  }
                  
                  response = client.invoke_model(
                      body=json.dumps(body),
                      modelId=os.environ.get('AWS_BEDROCK_MODEL_ID', 'anthropic.claude-3-sonnet-20240229-v1:0'),
                      accept='application/json',
                      contentType='application/json'
                  )
                  
                  response_body = json.loads(response.get('body').read())
                  return response_body['content'][0]['text']

              try:
                  log_info("Attempting to generate code with Claude...")
                  return retry_operation(_make_claude_request, max_retries=3)
              except Exception as e:
                  log_error(f"Claude generation failed: {str(e)}")
                  # Fallback response
                  return f"""
          # Code Generation Fallback

          **Task**: {task_description}

          Unfortunately, the AI code generation failed due to: {str(e)}

          ## Fallback Implementation Plan

          Based on your request "{task_description}", here are the recommended next steps:

          1. **Manual Implementation**: Please implement this feature manually following the existing code patterns in the project.
          2. **File Structure**: Consider creating new components in the `src/components/` directory.
          3. **TypeScript Types**: Add appropriate type definitions in relevant files.
          4. **Ionic Components**: Use Ionic React components for UI consistency.
          5. **Testing**: Add appropriate tests for the new functionality.

          ## Project Context
          {codebase_context[:2000]}

          Please refer to the existing code patterns and implement the feature accordingly.
          """

          def create_branch_and_commit(branch_name: str, generated_content: str) -> bool:
              """Create a new branch and commit the generated code"""
              try:
                  log_info(f"Setting up git configuration...")
                  subprocess.run(['git', 'config', 'user.name', 'Claude Bot'], check=True)
                  subprocess.run(['git', 'config', 'user.email', 'claude-bot@example.com'], check=True)

                  log_info(f"Creating branch: {branch_name}")
                  # Create and checkout new branch
                  result = subprocess.run(['git', 'checkout', '-b', branch_name], 
                                        capture_output=True, text=True)
                  if result.returncode != 0:
                      log_warning(f"Branch creation warning: {result.stderr}")
                      # Try to checkout existing branch
                      subprocess.run(['git', 'checkout', branch_name], check=True)
                  
                  # Create a summary file with the generated content
                  log_info("Creating summary file...")
                  with open('CLAUDE_GENERATED.md', 'w', encoding='utf-8') as f:
                      f.write(f"# Claude Generated Code\n\n")
                      f.write(f"**Task**: {os.environ.get('TASK_DESCRIPTION', 'N/A')}\n\n")
                      f.write(f"**Generated on**: {subprocess.check_output(['date']).decode().strip()}\n\n")
                      f.write("## Generated Content\n\n")
                      f.write("```\n")
                      f.write(generated_content)
                      f.write("\n```\n")
                  
                  log_info("Committing changes...")
                  # Stage and commit changes
                  subprocess.run(['git', 'add', '.'], check=True)
                  
                  commit_message = f'''Add Claude generated code

          Task: {os.environ.get("TASK_DESCRIPTION", "N/A")}

          Generated by Claude AI via Amazon Bedrock
          Workflow run: {os.environ.get("GITHUB_RUN_ID", "N/A")}
          '''
                  
                  subprocess.run(['git', 'commit', '-m', commit_message], check=True)
                  
                  log_info("Pushing branch...")
                  # Push branch with retry
                  def _push_branch():
                      subprocess.run(['git', 'push', '-u', 'origin', branch_name], check=True)
                  
                  retry_operation(_push_branch, max_retries=3)
                  
                  log_success("Branch created and pushed successfully")
                  return True
                  
              except subprocess.CalledProcessError as e:
                  log_error(f"Git operation failed: {e}")
                  log_error(f"Command output: {e.output if hasattr(e, 'output') else 'N/A'}")
                  return False
              except Exception as e:
                  log_error(f"Unexpected error during git operations: {str(e)}")
                  return False

          def create_pull_request(branch_name: str, task_description: str, generated_content: str) -> Optional[str]:
              """Create a pull request with the generated code"""
              try:
                  github_token = os.environ.get('GITHUB_TOKEN')
                  repo = os.environ.get('GITHUB_REPOSITORY')
                  
                  if not github_token or not repo:
                      log_error("Missing GitHub token or repository info")
                      return None
                  
                  headers = {
                      'Authorization': f'token {github_token}',
                      'Accept': 'application/vnd.github.v3+json'
                  }
                  
                  pr_body = f"""## ü§ñ Claude AI Generated Code

          **Task Description:** {task_description}

          This pull request contains code generated by Claude AI via Amazon Bedrock based on the requested feature.

          ## Generated Changes

          ```
          {generated_content[:2000]}{'...' if len(generated_content) > 2000 else ''}
          ```

          ## Review Notes

          - Please review the generated code carefully
          - Test the functionality before merging
          - Make any necessary adjustments for your specific requirements
          - Check for integration with existing codebase

          ## Workflow Information

          - **Triggered by**: {os.environ.get('GITHUB_EVENT_NAME', 'Unknown')}
          - **Run ID**: {os.environ.get('GITHUB_RUN_ID', 'Unknown')}
          - **Generated on**: {time.strftime('%Y-%m-%d %H:%M:%S UTC', time.gmtime())}

          ---
          *This PR was created automatically by Claude AI*
          """
                  
                  pr_data = {
                      'title': f'ü§ñ Claude Generated: {task_description[:50]}{"..." if len(task_description) > 50 else ""}',
                      'head': branch_name,
                      'base': 'main',
                      'body': pr_body
                  }
                  
                  def _create_pr():
                      url = f'https://api.github.com/repos/{repo}/pulls'
                      response = requests.post(url, headers=headers, json=pr_data, timeout=30)
                      
                      if response.status_code == 201:
                          return response.json()['html_url']
                      else:
                          raise Exception(f"API returned {response.status_code}: {response.text}")
                  
                  pr_url = retry_operation(_create_pr, max_retries=3)
                  log_success(f"Pull request created: {pr_url}")
                  return pr_url
                  
              except Exception as e:
                  log_error(f"Failed to create pull request: {str(e)}")
                  return None

          def main():
              try:
                  log_info("üöÄ Starting Claude code generation workflow...")
                  
                  # Get environment variables with defaults
                  task_description = os.environ.get('TASK_DESCRIPTION', 'Generate code improvement for the project')
                  branch_name = os.environ.get('TARGET_BRANCH', f'claude-generated-{int(time.time())}')
                  
                  log_info(f"Task: {task_description}")
                  log_info(f"Target branch: {branch_name}")
                  
                  # Analyze codebase
                  log_info("üìä Analyzing codebase...")
                  codebase_context = analyze_codebase()
                  
                  # Generate code with Claude
                  log_info("üß† Generating code with Claude...")
                  generated_content = generate_code_with_claude(task_description, codebase_context)
                  
                  if not generated_content:
                      raise Exception("No content generated")
                  
                  log_info(f"Generated {len(generated_content)} characters of content")
                  
                  # Create branch and commit
                  log_info(f"üåø Creating branch: {branch_name}")
                  if create_branch_and_commit(branch_name, generated_content):
                      # Create pull request
                      log_info("üìù Creating pull request...")
                      pr_url = create_pull_request(branch_name, task_description, generated_content)
                      
                      if pr_url:
                          log_success("üéâ Code generation completed successfully!")
                          log_success(f"Pull request: {pr_url}")
                      else:
                          log_warning("‚ö†Ô∏è Code generated but PR creation failed")
                          log_info("You can manually create a PR from the pushed branch")
                  else:
                      log_error("‚ùå Failed to create branch and commit changes")
                      sys.exit(1)
                      
              except Exception as e:
                  log_error(f"Workflow failed: {str(e)}")
                  # Don't exit with error - let the workflow continue
                  log_warning("Continuing despite errors to ensure workflow doesn't fail completely")

          if __name__ == "__main__":
              main()
          EOF

          echo "üêç Running Python script..."
          python claude_generator.py || echo "‚ö†Ô∏è Python script had issues but workflow continues"
          echo "‚úÖ Workflow completed"
